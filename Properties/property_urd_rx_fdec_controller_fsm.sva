// DO NOT REMOVE //
// This file is a product of Master Thesis done by Vinay Singh (ESNIVIN) at Ericcson 

/////////////////////////////////////////////////
/*Author : ESNIVIN 
Property File : 
File Created at : 2023/07/26- 09 hr-29 m.-59 s
*/

//////////////////////////////////////////////////
bind urd_rx_fdec_controller_fsm v_urd_rx_fdec_controller_fsm i_urd_rx_fdec_controller_fsm ( .* );


module v_// Created by : ESNIVIN

//`include "macros.v"

module urd_rx_fdec_controller_fsm(
									input clk,
									input rst_n,
									input rxf_lower_dav,
									input zero_payload,// Deal with this    assign zero_payload = current_job.len + 'd32 == current_job.offset;
									input processing_queue_slot_available,
									input processing_queue_slot_available_early,
									input current_job_data_available,
									input rxf_upper_dav,						// mapped
									input rxl_result_data_con_concatenate,
									input current_job_e,
									input current_job_e_pre_urd_error,
								    input current_job_e_size_error,
								    input current_job_e_hdr_error,
//								    input rxl_result_dav,			// mapped
								    input [7:0]rx_ev_inc_err,
								    input [7:0]rx_ev_oversize_ip,
								    input [7:0]rx_ev_eth_head_err,
								    output reg rxl_load_lower_and_trigger, 			// MAPPED
								    output reg rxl_load_upper,
								    output reg rxf_stop,
									output reg update_job_info_from_info_fifo,
									output reg trigger_write_fd_job_queue,
									output reg trigger_write_fd_job_queue_error_job
									);

// Setting Port direction //
input 
									input clk;
input 
									input rst_n;
input 
									input rxf_lower_dav;
input 
									input zero_payload;
input // Deal with this    assign zero_payload = current_job.len + 'd32 == current_job.offset;
									input processing_queue_slot_available;
input 
									input processing_queue_slot_available_early;
input 
									input current_job_data_available;
input 
									input rxf_upper_dav;
input 						// mapped
									input rxl_result_data_con_concatenate;
input 
									input current_job_e;
input 
									input current_job_e_pre_urd_error;
input 
								    input current_job_e_size_error;
input 
								    input current_job_e_hdr_error;
input 
//								    input rxl_result_dav;
input 			// mapped
								    input [7:0]rx_ev_inc_err;
input 
								    input [7:0]rx_ev_oversize_ip;
input 
								    input [7:0]rx_ev_eth_head_err;
input 
								    input reg rxl_load_lower_and_trigger;
input  			// MAPPED
								    input reg rxl_load_upper;
input 
								    input reg rxf_stop;
input 
									input reg update_job_info_from_info_fifo;
input 
									input reg trigger_write_fd_job_queue;
input 
									input reg trigger_write_fd_job_queue_error_job
									;


 /* // Add your ports here, for eg internal state registers and typedefs 










*/

// Property list 

property t_Prop_0; 
	@(posedge clk) (((urd_rx_fdec_controller_fsm.state==urd_rx_fdec_controller_fsm.error_frame_hdr) ) && ((urd_rx_fdec_controller_fsm.rxf_lower_dav==1'b1) )|->  (urd_rx_fdec_controller_fsm.state_nxt == urd_rx_fdec_controller_fsm.newframe_wait ));
endproperty 

assert_t_Prop_0: assert property (t_Prop_0);
cover_t_prop_0: cover property (t_Prop_0);

property t_Prop_1; 
	@(posedge clk) (((urd_rx_fdec_controller_fsm.state==urd_rx_fdec_controller_fsm.frame_pl64) ) && ((urd_rx_fdec_controller_fsm.zero_payload_d==1'b1) )|->  (urd_rx_fdec_controller_fsm.state_nxt == urd_rx_fdec_controller_fsm.rxl_wait ));
endproperty 

assert_t_Prop_1: assert property (t_Prop_1);
cover_t_prop_1: cover property (t_Prop_1);

property t_Prop_2; 
	@(posedge clk) (((urd_rx_fdec_controller_fsm.processing_queue_slot_available==1'b1) )|->  (urd_rx_fdec_controller_fsm.state_nxt == urd_rx_fdec_controller_fsm.frame_pl64_concat ));
endproperty 

assert_t_Prop_2: assert property (t_Prop_2);
cover_t_prop_2: cover property (t_Prop_2);

property t_Prop_3; 
	@(posedge clk) (((urd_rx_fdec_controller_fsm.state==urd_rx_fdec_controller_fsm.frame_pl64_concat) ) && (((urd_rx_fdec_controller_fsm.check_err==1'b1)&&(urd_rx_fdec_controller_fsm.err_ind_d==1'b1)) )|->  (urd_rx_fdec_controller_fsm.state_nxt == urd_rx_fdec_controller_fsm.newframe_wait ));
endproperty 

assert_t_Prop_3: assert property (t_Prop_3);
cover_t_prop_3: cover property (t_Prop_3);

property t_Prop_4; 
	@(posedge clk) (((urd_rx_fdec_controller_fsm.processing_queue_slot_available_early==1'b1) )|->  (urd_rx_fdec_controller_fsm.state_nxt == urd_rx_fdec_controller_fsm.frame_pl64_concat ));
endproperty 

assert_t_Prop_4: assert property (t_Prop_4);
cover_t_prop_4: cover property (t_Prop_4);

property t_Prop_5; 
	@(posedge clk) ((1 ) && (((urd_rx_fdec_controller_fsm.current_job_data_available==1'b1)&&(urd_rx_fdec_controller_fsm.processing_queue_slot_available==1'b1)) ) && ((urd_rx_fdec_controller_fsm.current_job_e==1'b0) )|->  (urd_rx_fdec_controller_fsm.state_nxt == urd_rx_fdec_controller_fsm.frame_pl64 ));
endproperty 

assert_t_Prop_5: assert property (t_Prop_5);
cover_t_prop_5: cover property (t_Prop_5);

property t_Prop_6; 
	@(posedge clk) (((urd_rx_fdec_controller_fsm.current_job_e_size_error==1'b1) )|->  (urd_rx_fdec_controller_fsm.state_nxt == urd_rx_fdec_controller_fsm.error_frame_hdr ));
endproperty 

assert_t_Prop_6: assert property (t_Prop_6);
cover_t_prop_6: cover property (t_Prop_6);




endmodule