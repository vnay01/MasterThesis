
 Entering Single Terminal Extractor
True:(Branch Cond:( Lor Next:(Terminal usb_test.send_data),(Terminal usb_test._rn0_tx_valid)) True:(Terminal usb_test._rn1_next_state) False:(Terminal usb_test._rn2_next_state))

 Terminal information:  send_data

*******************

Starting Flow at... 2023/07/28- 06 hr-56 m.-29 s


Iverilog command called with switches :  ['iverilog', '-E', '-o', 'preprocess.output']

Term:
(Term name:usb_test.CRC1 type:['Localparam'] msb:(IntConst 31) lsb:(IntConst 0))
(Term name:usb_test.CRC2 type:['Localparam'] msb:(IntConst 31) lsb:(IntConst 0))
(Term name:usb_test.IDLE type:['Localparam'] msb:(IntConst 31) lsb:(IntConst 0))
(Term name:usb_test.buff type:['Output', 'Reg'] msb:(IntConst 9) lsb:(IntConst 0))
(Term name:usb_test.clk type:['Input'] msb:(IntConst 0) lsb:(IntConst 0))
(Term name:usb_test.counter type:['Reg'] msb:(IntConst 9) lsb:(IntConst 0))
(Term name:usb_test.counter_next type:['Reg'] msb:(IntConst 9) lsb:(IntConst 0))
(Term name:usb_test.current_state type:['Reg'] msb:(IntConst 2) lsb:(IntConst 0))
(Term name:usb_test.next_state type:['Reg'] msb:(IntConst 2) lsb:(IntConst 0))
(Term name:usb_test.reset type:['Input'] msb:(IntConst 0) lsb:(IntConst 0))
(Term name:usb_test.send_data type:['Input'] msb:(IntConst 0) lsb:(IntConst 0))
(Term name:usb_test.tx_ready type:['Input'] msb:(IntConst 0) lsb:(IntConst 0))
(Term name:usb_test.tx_valid type:['Output', 'Reg'] msb:(IntConst 0) lsb:(IntConst 0))

 These are the nodes for which dataflow trees can be generated : 

 [0] List of Binding keys:  usb_test.IDLE

 [1] List of Binding keys:  usb_test.CRC1

 [2] List of Binding keys:  usb_test.CRC2

 [3] List of Binding keys:  usb_test.current_state

 [4] List of Binding keys:  usb_test.counter

 [5] List of Binding keys:  usb_test.counter_next

 [6] List of Binding keys:  usb_test.next_state

 [7] List of Binding keys:  usb_test.tx_valid

 [8] List of Binding keys:  usb_test.buff


 Generating tree structure for selected node : 
(Bind dest:usb_test.next_state tree:(Branch Cond:(Operator Eq Next:(Terminal usb_test.current_state),(Terminal usb_test.IDLE)) True:(Branch Cond:(Terminal usb_test.send_data) True:(Terminal usb_test.CRC1) False:(Terminal usb_test.current_state)) False:(Branch Cond:(Operator Eq Next:(Terminal usb_test.current_state),(Terminal usb_test.CRC1)) True:(Branch Cond:(Operator Ulnot Next:(Terminal usb_test.tx_ready)) True:(Terminal usb_test.CRC2) False:(Terminal usb_test.current_state)) False:(Branch Cond:(Operator Eq Next:(Terminal usb_test.current_state),(Terminal usb_test.CRC2)) True:(Branch Cond:(Terminal usb_test.tx_ready) True:(Branch Cond:(Operator LessThan Next:(Terminal usb_test.counter),(IntConst 9)) True:(Terminal usb_test.CRC1) False:(Terminal usb_test.current_state)) False:(Branch Cond:(Operator Eq Next:(Terminal usb_test.counter),(IntConst 10)) True:(Terminal usb_test.IDLE))) False:(Branch Cond:(IntConst 1) True:(Terminal usb_test.IDLE) False:(Terminal usb_test.current_state)))))) 
i is printed
 Pyverilog function call

 This is how Pyverilog creates a tree internally 
     assign usb_test.next_state = (((usb_test.current_state==usb_test.IDLE)) ? ((usb_test.send_data) ? usb_test.CRC1 : usb_test.current_state) : (((usb_test.current_state==usb_test.CRC1)) ? (((!usb_test.tx_ready)) ? usb_test.CRC2 : usb_test.current_state) : (((usb_test.current_state==usb_test.CRC2)) ? ((usb_test.tx_ready) ? (((usb_test.counter<9)) ? usb_test.CRC1 : usb_test.current_state) : (((usb_test.counter==10)) ? usb_test.IDLE : usb_test.next_state)) : ((1) ? usb_test.IDLE : usb_test.current_state))));

 *****modified function call *****

** Printing from dataflow.py usb_test.next_state Destination type  *** <class 'str'>

** Printing from dataflow.py usb_test.next_state Destination type  *** <class 'str'>

** Printing from dataflow.py usb_test.next_state Destination type  *** <class 'str'>

** Printing from dataflow.py usb_test.next_state Destination type  *** <class 'str'>

** Printing from dataflow.py usb_test.next_state Destination type  *** <class 'str'>

** Printing from dataflow.py usb_test.next_state Destination type  *** <class 'str'>

** Printing from dataflow.py usb_test.next_state Destination type  *** <class 'str'>

** Printing from dataflow.py usb_test.next_state Destination type  *** <class 'str'>

** Printing from dataflow.py usb_test.next_state Destination type  *** <class 'str'>

 Prinitng length of a:  713

 Printing line_buff 
: ['((usb_test.current_state==usb_test.IDLE) ) && (usb_test.send_data ) && |->  (usb_test.next_state == usb_test.CRC1 )', 'usb_test.next_state == usb_test.current_state;', '', '', ' ((usb_test.current_state==usb_test.CRC1) ) && ((!usb_test.tx_ready) ) && |->  (usb_test.next_state == usb_test.CRC2 )', 'usb_test.next_state == usb_test.current_state;', '', '', ' ((usb_test.current_state==usb_test.CRC2) ) && (usb_test.tx_ready ) && ((usb_test.counter<9) ) && |->  (usb_test.next_state == usb_test.CRC1 )', 'usb_test.next_state == usb_test.current_state;', '', '', ' ((usb_test.counter==10) ) && |->  (usb_test.next_state == usb_test.IDLE )', '', '', ' (1 ) && |->  (usb_test.next_state == usb_test.IDLE )', 'usb_test.next_state == usb_test.current_state;', '', '', '', '', ' &&']

 Modified Line_buff 
 ['((usb_test.current_state==usb_test.IDLE) ) && (usb_test.send_data ) && |->  (usb_test.next_state == usb_test.CRC1 )', 'usb_test.next_state == usb_test.current_state;', '', '', ' ((usb_test.current_state==usb_test.CRC1) ) && ((!usb_test.tx_ready) ) && |->  (usb_test.next_state == usb_test.CRC2 )', 'usb_test.next_state == usb_test.current_state;', '', '', ' ((usb_test.current_state==usb_test.CRC2) ) && (usb_test.tx_ready ) && ((usb_test.counter<9) ) && |->  (usb_test.next_state == usb_test.CRC1 )', 'usb_test.next_state == usb_test.current_state;', '', '', ' ((usb_test.counter==10) ) && |->  (usb_test.next_state == usb_test.IDLE )', '', '', ' (1 ) && |->  (usb_test.next_state == usb_test.IDLE )', 'usb_test.next_state == usb_test.current_state;', '', '', '', '', ' &&']


 Number of items in line_buff 
:  22

 type :  <class 'list'>


 True_condition_property: 
[0]   ((usb_test.current_state==usb_test.IDLE) ) && (usb_test.send_data ) && |->  (usb_test.next_state == usb_test.CRC1 )
[1]   
[2]    ((usb_test.current_state==usb_test.CRC1) ) && ((!usb_test.tx_ready) ) && |->  (usb_test.next_state == usb_test.CRC2 )
[3]   
[4]    ((usb_test.current_state==usb_test.CRC2) ) && (usb_test.tx_ready ) && ((usb_test.counter<9) ) && |->  (usb_test.next_state == usb_test.CRC1 )
[5]   
[6]    ((usb_test.counter==10) ) && |->  (usb_test.next_state == usb_test.IDLE )
[7]   
[8]   usb_test.next_state == usb_test.current_state;
[9]   
[10]   


 False_condition_property:  ['usb_test.next_state == usb_test.current_state', '', 'usb_test.next_state == usb_test.current_state', '', 'usb_test.next_state == usb_test.current_state', '', '', ' (1 ) && |->  (usb_test.next_state == usb_test.IDLE )', '', '', ' &&']
\ length of prop_list :  11
[0]  True part ((usb_test.current_state==usb_test.IDLE) ) && (usb_test.send_data )|->  (usb_test.next_state == usb_test.CRC1 )
[0]  False Part ((usb_test.current_state==usb_test.IDLE) ) && (usb_test.send_data )|-> (usb_test.next_state == usb_test.current_state )

 Handle logic for nested conditions here
[2]  True part ((usb_test.current_state==usb_test.CRC1) ) && ((!usb_test.tx_ready) )|->  (usb_test.next_state == usb_test.CRC2 )
[2]  False Part ((usb_test.current_state==usb_test.CRC1) ) && ((!usb_test.tx_ready) )|-> (usb_test.next_state == usb_test.current_state )

 Handle logic for nested conditions here
[4]  True part ((usb_test.current_state==usb_test.CRC2) ) && (usb_test.tx_ready ) && ((usb_test.counter<9) )|->  (usb_test.next_state == usb_test.CRC1 )
[4]  False Part ((usb_test.current_state==usb_test.CRC2) ) && (usb_test.tx_ready ) && ((usb_test.counter<9) )|-> (usb_test.next_state == usb_test.current_state )

 Handle logic for nested conditions here
[6]  True part ((usb_test.counter==10) )|->  (usb_test.next_state == usb_test.IDLE )
[6]  False Part ((usb_test.counter==10) )|-> ( )

 Handle logic for nested conditions here

 Handle logic for nested conditions here

 Handle logic for nested conditions here

 Handle logic for nested conditions here


 true_part :  ['((usb_test.current_state==usb_test.IDLE) ) && (usb_test.send_data )|->  (usb_test.next_state == usb_test.CRC1 )', '((usb_test.current_state==usb_test.CRC1) ) && ((!usb_test.tx_ready) )|->  (usb_test.next_state == usb_test.CRC2 )', '((usb_test.current_state==usb_test.CRC2) ) && (usb_test.tx_ready ) && ((usb_test.counter<9) )|->  (usb_test.next_state == usb_test.CRC1 )', '((usb_test.counter==10) )|->  (usb_test.next_state == usb_test.IDLE )']


 false_part :  ['((usb_test.current_state==usb_test.IDLE) ) && (usb_test.send_data )|-> (usb_test.next_state == usb_test.current_state )', '((usb_test.current_state==usb_test.CRC1) ) && ((!usb_test.tx_ready) )|-> (usb_test.next_state == usb_test.current_state )', '((usb_test.current_state==usb_test.CRC2) ) && (usb_test.tx_ready ) && ((usb_test.counter<9) )|-> (usb_test.next_state == usb_test.current_state )', '((usb_test.counter==10) )|-> ( )']
module_name :  usb_test
copied_block:  module v_usb_test (clk, reset, send_data, tx_ready, tx_valid, buff);

 Adding false properties*******

