
 Entering Single Terminal Extractor
True:(Branch Cond:( Lor Next:(Terminal usb_test.send_data),(Terminal usb_test._rn0_tx_valid)) True:(Terminal usb_test._rn1_next_state) False:(Terminal usb_test._rn2_next_state))

 Terminal information:  send_data

*******************

Starting Flow at... 2023/07/10- 11 hr-42 m.-21 s

 These are the nodes for which dataflow trees can be generated : 

 [0] List of Binding keys:  usb_test.IDLE

 [1] List of Binding keys:  usb_test.CRC1

 [2] List of Binding keys:  usb_test.CRC2

 [3] List of Binding keys:  usb_test.current_state

 [4] List of Binding keys:  usb_test.tx_valid

 [5] List of Binding keys:  usb_test.next_state

 [6] List of Binding keys:  usb_test.buff


 Generating tree structure for selected node : 
 Pyverilog function call

 assign usb_test.next_state = (((usb_test.current_state==usb_test.IDLE)) ? ((usb_test.send_data) ? usb_test.CRC1 : usb_test.IDLE) : (((usb_test.current_state==usb_test.CRC1)) ? (((!usb_test.tx_ready)) ? usb_test.CRC2 : usb_test.CRC1) : (((usb_test.current_state==usb_test.CRC2)) ? ((usb_test.tx_ready) ? usb_test.IDLE : usb_test.CRC2) : ((1) ? usb_test.IDLE : usb_test.next_state))));

 modified function call

 Prinitng length of a:  534

 Printing line_buff 
: ['((usb_test.current_state==usb_test.IDLE) ) && (usb_test.send_data ) && |->  (usb_test.next_state == usb_test.CRC1 )', 'usb_test.next_state == usb_test.IDLE;', '', '', ' ((usb_test.current_state==usb_test.CRC1) ) && ((!usb_test.tx_ready) ) && |->  (usb_test.next_state == usb_test.CRC2 )', 'usb_test.next_state == usb_test.CRC1;', '', '', ' ((usb_test.current_state==usb_test.CRC2) ) && (usb_test.tx_ready ) && |->  (usb_test.next_state == usb_test.IDLE )', 'usb_test.next_state == usb_test.CRC2;', '', '', ' (1 ) && |->  (usb_test.next_state == usb_test.IDLE )', '', '', '', ' &&']

 Modified Line_buff 
 ['((usb_test.current_state==usb_test.IDLE) ) && (usb_test.send_data ) && |->  (usb_test.next_state == usb_test.CRC1 )', 'usb_test.next_state == usb_test.IDLE;', ' ((usb_test.current_state==usb_test.CRC1) ) && ((!usb_test.tx_ready) ) && |->  (usb_test.next_state == usb_test.CRC2 )', 'usb_test.next_state == usb_test.CRC1;', ' ((usb_test.current_state==usb_test.CRC2) ) && (usb_test.tx_ready ) && |->  (usb_test.next_state == usb_test.IDLE )', 'usb_test.next_state == usb_test.CRC2;', ' (1 ) && |->  (usb_test.next_state == usb_test.IDLE )', ' &&']


 Number of items in line_buff 
:  8

 type :  <class 'list'>


 True_condition_property:  ['((usb_test.current_state==usb_test.IDLE) ) && (usb_test.send_data ) && |->  (usb_test.next_state == usb_test.CRC1 )', ' ((usb_test.current_state==usb_test.CRC1) ) && ((!usb_test.tx_ready) ) && |->  (usb_test.next_state == usb_test.CRC2 )', ' ((usb_test.current_state==usb_test.CRC2) ) && (usb_test.tx_ready ) && |->  (usb_test.next_state == usb_test.IDLE )', ' (1 ) && |->  (usb_test.next_state == usb_test.IDLE )']


 False_condition_property:  ['usb_test.next_state == usb_test.IDLE;', 'usb_test.next_state == usb_test.CRC1;', 'usb_test.next_state == usb_test.CRC2;', ' &&']
\ length of prop_list :  4
[0]   ((usb_test.current_state==usb_test.IDLE) ) && (usb_test.send_data )|->  (usb_test.next_state == usb_test.CRC1 )
[0]   ((usb_test.current_state==usb_test.IDLE) ) && (usb_test.send_data )|-> (usb_test.next_state == usb_test.IDLE );
[1]   ((usb_test.current_state==usb_test.CRC1) ) && ((!usb_test.tx_ready) )|->  (usb_test.next_state == usb_test.CRC2 )
[1]   ((usb_test.current_state==usb_test.CRC1) ) && ((!usb_test.tx_ready) )|-> (usb_test.next_state == usb_test.CRC1 );
[2]   ((usb_test.current_state==usb_test.CRC2) ) && (usb_test.tx_ready )|->  (usb_test.next_state == usb_test.IDLE )
[2]   ((usb_test.current_state==usb_test.CRC2) ) && (usb_test.tx_ready )|-> (usb_test.next_state == usb_test.CRC2 );
[3]   (1 )|->  (usb_test.next_state == usb_test.IDLE )
[3]   (1 )|-> ( && );


 true_part :  ['((usb_test.current_state==usb_test.IDLE) ) && (usb_test.send_data )|->  (usb_test.next_state == usb_test.CRC1 )', '((usb_test.current_state==usb_test.CRC1) ) && ((!usb_test.tx_ready) )|->  (usb_test.next_state == usb_test.CRC2 )', '((usb_test.current_state==usb_test.CRC2) ) && (usb_test.tx_ready )|->  (usb_test.next_state == usb_test.IDLE )', '(1 )|->  (usb_test.next_state == usb_test.IDLE )']


 false_part :  ['((usb_test.current_state==usb_test.IDLE) ) && (usb_test.send_data )|-> (usb_test.next_state == usb_test.IDLE );', '((usb_test.current_state==usb_test.CRC1) ) && ((!usb_test.tx_ready) )|-> (usb_test.next_state == usb_test.CRC1 );', '((usb_test.current_state==usb_test.CRC2) ) && (usb_test.tx_ready )|-> (usb_test.next_state == usb_test.CRC2 );', '(1 )|-> ( && );']
copied_block:  module usb_test (clk, reset, send_data, tx_ready, tx_valid, buff);
//////////////////////////////////////////////////

