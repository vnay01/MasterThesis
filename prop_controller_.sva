module controller(  
                    clk,
                    reset,  // ACTIVE LOW reset
                    START,
                    MEM_READ,         
                    BUSY,
                    DONE,
                    input_matrix_ram_en,
                    input_matrix_ram_read_en,
                    input_matrix_ram_address,
                    filter_matrix_rom_en,
                    filter_matrix_rom_read_en,
                    filter_matrix_rom_address,
                    data_path_signal,
                    fifo_command                             
    )

// Setting Port direction //
input   
                    clk
input 
                    reset
input   // ACTIVE LOW reset
                    START
input 
                    MEM_READ
input          
                    BUSY
input 
                    DONE
input 
                    input_matrix_ram_en
input 
                    input_matrix_ram_read_en
input 
                    input_matrix_ram_address
input 
                    filter_matrix_rom_en
input 
                    filter_matrix_rom_read_en
input 
                    filter_matrix_rom_address
input 
                    data_path_signal
input 
                    fifo_command                             
    

// Property list

property Prop_0; 
	@(posedge clk) ((current_state == INIT)&&( START) |-> (next_state == current_state));
endproperty 

assert_Prop_0: assert property (Prop_0);

property Prop_1; 
	@(posedge clk) ((current_state == LOAD)&&(count ==  1) |-> (next_state == MULT));
endproperty 

assert_Prop_1: assert property (Prop_1);

property Prop_2; 
	@(posedge clk) ((current_state == MULT)&&(count ==  15) |-> (next_state == L1_ADD));
endproperty 

assert_Prop_2: assert property (Prop_2);

property Prop_3; 
	@(posedge clk) ((current_state == L1_ADD)&&(count ==  7) |-> (next_state == L2_ADD));
endproperty 

assert_Prop_3: assert property (Prop_3);

property Prop_4; 
	@(posedge clk) ((current_state == L2_ADD)&&(count ==  7) |-> (next_state == L3_ADD));
endproperty 

assert_Prop_4: assert property (Prop_4);

property Prop_5; 
	@(posedge clk) ((current_state == L3_ADD)&&(count ==  7) |-> (next_state == L4_ADD));
endproperty 

assert_Prop_5: assert property (Prop_5);

property Prop_6; 
	@(posedge clk) ((current_state == L4_ADD)&&(count ==  7) |-> (next_state == MEM_STORE));
endproperty 

assert_Prop_6: assert property (Prop_6);

property Prop_7; 
	@(posedge clk) ((current_state == MEM_STORE)&&(state_counter ==  256) |-> (next_state == INIT));
endproperty 

assert_Prop_7: assert property (Prop_7);

property Prop_8; 
	@(posedge clk) ((count ==  10)&&( LOAD) |-> (next_state == why));
endproperty 

assert_Prop_8: assert property (Prop_8);


endmodule