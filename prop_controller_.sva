module controller(  
                     input clk,
                     input reset,
                     input START,      
                     input MEM_READ,   
                     output reg BUSY,
                     output reg DONE,
                     output reg input_matrix_ram_en,
                     output reg input_matrix_ram_read_en,
                     output reg [9:0] input_matrix_ram_address,
                     output reg filter_matrix_rom_en,
                     output reg filter_matrix_rom_read_en,
                     output reg filter_matrix_rom_address,
                     output reg [4:0] data_path_signal,          // concatnation of signals which control different sections of datapath
                     output reg [1:0] fifo_command                          
    );

// Setting Port direction //
input   
                      clk;
input 
                      reset;
input 
                      START;
input       
                      MEM_READ;
input    
                       BUSY;
input 
                       DONE;
input 
                       _matrix_ram_en;
input 
                       _matrix_ram_read_en;
input 
                       [9:0] _matrix_ram_address;
input 
                       filter_matrix_rom_en;
input 
                       filter_matrix_rom_read_en;
input 
                       filter_matrix_rom_address;
input 
                       [4:0] data_path_signal;
input           // concatnation of signals which control different sections of datapath
                       [1:0] fifo_command                          
    ;
// Default Clocking and Reset
//default clocking (@posedge clk); clocking
// Property list 

//  Property Generated on Timestamp : 2023/07/03- 16 hr-03 m.-07 s
property Prop_0; 
	@(posedge clk) ((current_state == INIT)&&( START) |-> (next_state == INIT));
endproperty 

assert_Prop_0: assert property (Prop_0);
cover_prop_0: cover property (Prop_0);

property Prop_1; 
	@(posedge clk) ((current_state == LOAD)&&(count ==  1) |-> (next_state == MULT));
endproperty 

assert_Prop_1: assert property (Prop_1);
cover_prop_1: cover property (Prop_1);

property Prop_2; 
	@(posedge clk) ((current_state == MULT)&&(count ==  15) |-> (next_state == L1_ADD));
endproperty 

assert_Prop_2: assert property (Prop_2);
cover_prop_2: cover property (Prop_2);

property Prop_3; 
	@(posedge clk) ((current_state == L1_ADD)&&(count ==  7) |-> (next_state == L2_ADD));
endproperty 

assert_Prop_3: assert property (Prop_3);
cover_prop_3: cover property (Prop_3);

property Prop_4; 
	@(posedge clk) ((current_state == L2_ADD)&&(count ==  7) |-> (next_state == L3_ADD));
endproperty 

assert_Prop_4: assert property (Prop_4);
cover_prop_4: cover property (Prop_4);

property Prop_5; 
	@(posedge clk) ((current_state == L3_ADD)&&(count ==  7) |-> (next_state == L4_ADD));
endproperty 

assert_Prop_5: assert property (Prop_5);
cover_prop_5: cover property (Prop_5);

property Prop_6; 
	@(posedge clk) ((current_state == L4_ADD)&&(count ==  7) |-> (next_state == MEM_STORE));
endproperty 

assert_Prop_6: assert property (Prop_6);
cover_prop_6: cover property (Prop_6);

property Prop_7; 
	@(posedge clk) ((current_state == MEM_STORE)&&(state_counter ==  256) |-> (next_state == INIT));
endproperty 

assert_Prop_7: assert property (Prop_7);
cover_prop_7: cover property (Prop_7);

property Prop_8; 
	@(posedge clk) ((count ==  10)&&( LOAD) |-> (next_state == why));
endproperty 

assert_Prop_8: assert property (Prop_8);
cover_prop_8: cover property (Prop_8);


endmodule